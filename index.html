<!DOCTYPE html>
<!-- disable-loop-protection -->
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Collatz Tree Visualiser</title>
<style>
body {
    font-family: sans-serif;
    background-color: #f0f0f0;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    margin: 0;
    overflow: hidden;
}
#visualiser {
    position: relative;
    width: 100%;
    height: 100%;
    background-color: #fff;
    overflow: hidden;
}
#scene {
    position: absolute;
    top: 0;
    left: 0;
    transform-origin: 0 0;
}
.node {
    width: 40px;
    height: 40px;
    background-color: #007bff;
    color: white;
    border-radius: 50%;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 14px;
    position: absolute;
    cursor: pointer;
    transform: translate(-50%, -50%);
    z-index: 1;
}
.line {
    position: absolute;
    background-color: #ccc;
    height: 2px;
    transform-origin: 0 50%;
    pointer-events: none;
}
.node.path-highlight {
    box-shadow: 0 0 10px 3px yellow;
}
.line.path-highlight {
    background-color: yellow;
}
</style>
</head>

<body>
<div id="visualiser">
    <div id="scene"></div>
</div>

<script>
// ===== Core =====
const visualiser = document.getElementById("visualiser");
const scene = document.getElementById("scene");

let nodes = {};
let links = [];

// ===== Camera =====
let camera = { x: 0, y: 0, scale: 1 };

function updateCamera() {
    scene.style.transform = `translate(${camera.x}px, ${camera.y}px) scale(${camera.scale})`;
}
camera.x = window.innerWidth / 2;
camera.y = window.innerHeight / 2;
updateCamera();

// ===== Collatz =====
function predecessors(n) {
    const out = [n * 2];
    if ((n - 1) % 3 === 0) {
        const p = (n - 1) / 3;
        if (p > 0 && p % 2) out.push(p);
    }
    return out;
}

// ===== Biased queue selection =====
function pickBiasedFromQueue(queue) {
    const bias = 1.25; // â†‘ = more low-value nodes

    let total = 0;
    const weights = [];

    for (let i = 0; i < queue.length; i++) {
        const v = queue[i].value;
        const w = 1 / Math.pow(Math.log2(v + 2), bias);
        weights.push(w);
        total += w;
    }

    let r = Math.random() * total;
    for (let i = 0; i < queue.length; i++) {
        r -= weights[i];
        if (r <= 0) {
            return queue.splice(i, 1)[0];
        }
    }
    return queue.shift();
}

// ===== Node drawing =====
function createNode(v) {
    const el = document.createElement("div");
    el.className = "node";
    el.textContent = v;
    scene.appendChild(el);
    nodes[v].el = el;
}

function updateNodes() {
    for (const v in nodes) {
        const n = nodes[v];
        n.el.style.left = n.x + "px";
        n.el.style.top = n.y + "px";
    }
}

function updateLines() {
    scene.querySelectorAll(".line").forEach(l => l.remove());
    for (const l of links) {
        const a = nodes[l.a];
        const b = nodes[l.b];
        const dx = b.x - a.x;
        const dy = b.y - a.y;
        const len = Math.hypot(dx, dy);
        const angle = Math.atan2(dy, dx);

        const line = document.createElement("div");
        line.className = "line";
        line.style.width = len + "px";
        line.style.left = a.x + "px";
        line.style.top = a.y + "px";
        line.style.transform = `rotate(${angle}rad)`;
        scene.appendChild(line);
    }
}

// ===== Queue expansion =====
let queue = [{ value: 1, parent: null }];

function addNode() {
    if (!queue.length) return;

    const cur = pickBiasedFromQueue(queue);
    const v = cur.value;

    if (nodes[v]) return;

    let x = 0, y = 0;
    if (cur.parent !== null && nodes[cur.parent]) {
        const p = nodes[cur.parent];
        const a = Math.random() * Math.PI * 2;
        x = p.x + Math.cos(a) * 80;
        y = p.y + Math.sin(a) * 80;
        links.push({ a: cur.parent, b: v });
    } else {
        x = (Math.random() - 0.5) * 400;
        y = (Math.random() - 0.5) * 400;
    }

    nodes[v] = { x, y };
    createNode(v);

    for (const p of predecessors(v)) {
        if (!nodes[p]) {
            queue.push({ value: p, parent: v });
        }
    }
}

// ===== Loop =====
function loop() {
    if (Math.random() < 0.25) addNode();
    updateLines();
    updateNodes();
    requestAnimationFrame(loop);
}

addNode();
loop();
</script>
</body>
</html>
